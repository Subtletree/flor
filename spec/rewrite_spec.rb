
#
# specifying flor
#
# Mon Dec 28 17:53:25 JST 2015
#

require 'spec_helper'


describe Flor do

  describe '.rewrite_tree' do

    [
      [
        ">\n" +
        "  a\n" +
        "  b\n",
        [ '>', {}, 1, [
          [ 'a', {}, 2, [] ],
          [ 'b', {}, 3, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "a > b",
        [ '>', {}, 1, [
          [ 'a', {}, 1, [] ],
          [ 'b', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "> a b",
        [ '>', {}, 1, [
          [ 'a', {}, 1, [] ],
          [ 'b', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "a b > c d",
        [ '>', {}, 1, [
          [ 'a', { _0: 'b' }, 1, [] ],
          [ 'c', { _0: 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "a or b or c",
        [ 'or', {}, 1, [
          [ 'a', {}, 1, [] ],
          [ 'b', {}, 1, [] ],
          [ 'c', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "a or b and c",
        [ 'or', {}, 1, [
          [ 'a', {}, 1, [] ],
          [ 'b', { '_0' => 'and', '_1' => 'c' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "a and (b or c)",
        [ 'and', {}, 1, [
          [ 'a', {}, 1, [] ],
          [ 'b', { '_0' => 'or', '_1' => 'c' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "(a or b) and c",
        [ 'and', {}, 1, [
          [ 'a', { '_0' => 'or', '_1' => 'b' }, 1, [] ],
          [ 'c', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "trace a or (trace b or trace c)",
        [ 'or', {}, 1, [
          [ 'trace', {
            '_0' => 'a' }, 1, [] ],
          [ 'trace', {
            '_0' => 'b', '_1' => 'or', '_2' => 'trace', '_3' => 'c' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

        #("$(cmp) x y", fdja_v("{ cmp:  > }"));
        #  [ >, {}, 1, [
        #    [ x, {}, 1, [] ],
        #    [ y, {}, 1, [] ]
        #  ], 'sx' ],

        #("x $(cmp) y", fdja_v("{ cmp:  > }"));
        #  [ >, {}, 1, [
        #    [ x, {}, 1, [] ],
        #    [ y, {}, 1, [] ]
        #  ], 'sx' ],

      [
        "if a",
        [ 'if', {}, 1, [
          [ 'a', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "unless a",
        [ 'unless', {}, 1, [
          [ 'a', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "if a > b",
        [ 'if', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "if a > b\n" +
        "  c d",
        [ 'if', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 2, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "if \n" +
        "  a > b\n" +
        "  c d\n",
        [ 'if', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 2, [] ],
          [ 'c', { '_0' => 'd' }, 3, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "if true\n",
        [ 'if', {}, 1, [
          [ 'val', { '_0' => true }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "elif true\n",
        [ 'elif', {}, 1, [
          [ 'val', { '_0' => true }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "elsif true\n",
        [ 'elsif', {}, 1, [
          [ 'val', { '_0' => true }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "if a > b then c d\n",
        [ 'ife', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "if a > b then c d else e f\n",
        [ 'ife', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 1, [] ],
          [ 'e', { '_0' => 'f' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "elsif a > b then c d\n",
        [ 'elsif', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "else if a > b then c d\n",
        [ 'elsif', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "c d if a > b\n",
        [ 'ife', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "c if a > b\n" +
        "  e f\n" +
        "  g h\n",
        [ 'ife', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', {}, 1, [
            [ 'e', { '_0' => 'f' }, 2, [] ],
            [ 'g', { '_0' => 'h' }, 3, [] ]
          ] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "c d unless a > b\n",
        [ 'unlesse', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ],
          [ 'c', { '_0' => 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "else if a > b\n",
        [ 'elsif', {}, 1, [
          [ 'a', { '_0' => '>', '_1' => 'b' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "else c d\n",
        [ 'else', {}, 1, [
          [ 'c', { '_0' => 'd' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "set\n",
        [ 'set', {}, 1, [], 'sx' ],
        __LINE__ ],

      [
        "set k\n" +
        "  v\n",
        [ 'set', { '_0' => 'k' }, 1, [
          [ 'v', {}, 2, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "set k: v\n",
        [ 'set', { '_0' => 'k' }, 1, [
          [ 'v', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "set k0: v0, k1: v1\n",
        [ 'sequence', {}, 1, [
          [ 'set', { '_0' => 'k0' }, 1, [
            [ 'v0', {}, 1, [] ]
          ] ],
          [ 'set', { '_0' => 'k1' }, 1, [
            [ 'v1', {}, 1, [] ]
          ] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "set k0: v0, k1: (a + 1), k2: v2\n",
        [ 'sequence', {}, 1, [
          [ 'set', { '_0' => 'k0' }, 1, [
            [ 'v0', {}, 1, [] ]
          ] ],
          [ 'set', { '_0' => 'k1' }, 1, [
            [ 'a', { '_0' => '+', '_1' => 1 }, 1, [] ]
          ] ],
          [ 'set', { '_0' => 'k2' }, 1, [
            [ 'v2', {}, 1, [] ]
          ] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "set k: 1\n",
        [ 'set', { '_0' => 'k' }, 1, [
          [ 'val', { '_0' => '1' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "set k: blue\n",
        [ 'set', { '_0' => 'k' }, 1, [
          [ 'blue', {}, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "task bob count: (+ 1 2)\n",
        [ 'sequence', {}, 1, [
          [ 'set', { '_0' => 'w._0' }, 1, [
            [ '+', { '_0' => 1, '_1' => 2 }, 1, [] ]
          ] ],
          [ 'task', { '_0' => 'bob', 'count' => '$(w._0)' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

      [
        "sub (1 + 2)\n",
        [ 'sequence', {}, 1, [
          [ 'set', { '_0' => 'w._0' }, 1, [
            [ 1, { '_0' => '+', '_1' => 2 }, 1, [] ]
          ] ],
          [ 'sub', { '_0' => '$(w._0)' }, 1, [] ]
        ], 'sx' ],
        __LINE__ ],

    ].each do |source, tree, line|

      title = "rewrites #{source.inspect} rw#{line}"

      #pending(title)
        #
      #it(title) do
      #  t = Flor::Radial.parse(source, 'sx')
      #  t = Flor.rewrite_tree(t)
      #  expect(t).to eq(tree)
      #end
    end
  end
end

